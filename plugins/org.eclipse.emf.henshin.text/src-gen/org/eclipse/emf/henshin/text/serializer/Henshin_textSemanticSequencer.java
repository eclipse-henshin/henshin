/*
 * generated by Xtext 2.16.0
 */
package org.eclipse.emf.henshin.text.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.henshin.text.henshin_text.AND;
import org.eclipse.emf.henshin.text.henshin_text.AndExpression;
import org.eclipse.emf.henshin.text.henshin_text.Attribute;
import org.eclipse.emf.henshin.text.henshin_text.BoolValue;
import org.eclipse.emf.henshin.text.henshin_text.BracketExpression;
import org.eclipse.emf.henshin.text.henshin_text.Call;
import org.eclipse.emf.henshin.text.henshin_text.CheckDangling;
import org.eclipse.emf.henshin.text.henshin_text.ComparisonExpression;
import org.eclipse.emf.henshin.text.henshin_text.ConditionEdge;
import org.eclipse.emf.henshin.text.henshin_text.ConditionEdges;
import org.eclipse.emf.henshin.text.henshin_text.ConditionGraph;
import org.eclipse.emf.henshin.text.henshin_text.ConditionGraphRef;
import org.eclipse.emf.henshin.text.henshin_text.ConditionNode;
import org.eclipse.emf.henshin.text.henshin_text.ConditionReuseNode;
import org.eclipse.emf.henshin.text.henshin_text.ConditionalUnit;
import org.eclipse.emf.henshin.text.henshin_text.Conditions;
import org.eclipse.emf.henshin.text.henshin_text.EPackageImport;
import org.eclipse.emf.henshin.text.henshin_text.Edge;
import org.eclipse.emf.henshin.text.henshin_text.Edges;
import org.eclipse.emf.henshin.text.henshin_text.EqualityExpression;
import org.eclipse.emf.henshin.text.henshin_text.Formula;
import org.eclipse.emf.henshin.text.henshin_text.Graph;
import org.eclipse.emf.henshin.text.henshin_text.Henshin_textPackage;
import org.eclipse.emf.henshin.text.henshin_text.IndependentUnit;
import org.eclipse.emf.henshin.text.henshin_text.InjectiveMatching;
import org.eclipse.emf.henshin.text.henshin_text.IntegerValue;
import org.eclipse.emf.henshin.text.henshin_text.IteratedUnit;
import org.eclipse.emf.henshin.text.henshin_text.JavaAttributeValue;
import org.eclipse.emf.henshin.text.henshin_text.JavaClassValue;
import org.eclipse.emf.henshin.text.henshin_text.JavaImport;
import org.eclipse.emf.henshin.text.henshin_text.List;
import org.eclipse.emf.henshin.text.henshin_text.LoopUnit;
import org.eclipse.emf.henshin.text.henshin_text.Match;
import org.eclipse.emf.henshin.text.henshin_text.MinusExpression;
import org.eclipse.emf.henshin.text.henshin_text.Model;
import org.eclipse.emf.henshin.text.henshin_text.MulOrDivExpression;
import org.eclipse.emf.henshin.text.henshin_text.MultiRule;
import org.eclipse.emf.henshin.text.henshin_text.MultiRuleReuseNode;
import org.eclipse.emf.henshin.text.henshin_text.NaturalValue;
import org.eclipse.emf.henshin.text.henshin_text.Node;
import org.eclipse.emf.henshin.text.henshin_text.Not;
import org.eclipse.emf.henshin.text.henshin_text.NotExpression;
import org.eclipse.emf.henshin.text.henshin_text.NumberValue;
import org.eclipse.emf.henshin.text.henshin_text.ORorXOR;
import org.eclipse.emf.henshin.text.henshin_text.OrExpression;
import org.eclipse.emf.henshin.text.henshin_text.ParameterType;
import org.eclipse.emf.henshin.text.henshin_text.ParameterValue;
import org.eclipse.emf.henshin.text.henshin_text.PlusExpression;
import org.eclipse.emf.henshin.text.henshin_text.PriorityUnit;
import org.eclipse.emf.henshin.text.henshin_text.Rollback;
import org.eclipse.emf.henshin.text.henshin_text.Rule;
import org.eclipse.emf.henshin.text.henshin_text.Strict;
import org.eclipse.emf.henshin.text.henshin_text.StringValue;
import org.eclipse.emf.henshin.text.henshin_text.Unit;
import org.eclipse.emf.henshin.text.henshin_text.UnitElement;
import org.eclipse.emf.henshin.text.services.Henshin_textGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class Henshin_textSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Henshin_textGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Henshin_textPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Henshin_textPackage.AND:
				sequence_AND(context, (AND) semanticObject); 
				return; 
			case Henshin_textPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case Henshin_textPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case Henshin_textPackage.BOOL_VALUE:
				sequence_AtomicExpression(context, (BoolValue) semanticObject); 
				return; 
			case Henshin_textPackage.BRACKET_EXPRESSION:
				sequence_PrimaryExpression(context, (BracketExpression) semanticObject); 
				return; 
			case Henshin_textPackage.CALL:
				sequence_UnitElement(context, (Call) semanticObject); 
				return; 
			case Henshin_textPackage.CHECK_DANGLING:
				sequence_CheckDangling(context, (CheckDangling) semanticObject); 
				return; 
			case Henshin_textPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITION_EDGE:
				sequence_ConditionEdge(context, (ConditionEdge) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITION_EDGES:
				sequence_ConditionEdges(context, (ConditionEdges) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITION_GRAPH:
				sequence_ConditionGraph(context, (ConditionGraph) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITION_GRAPH_REF:
				sequence_Atomic(context, (ConditionGraphRef) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITION_NODE:
				sequence_ConditionNode(context, (ConditionNode) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITION_REUSE_NODE:
				sequence_ConditionReuseNode(context, (ConditionReuseNode) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITIONAL_UNIT:
				sequence_ConditionalUnit(context, (ConditionalUnit) semanticObject); 
				return; 
			case Henshin_textPackage.CONDITIONS:
				sequence_Conditions(context, (Conditions) semanticObject); 
				return; 
			case Henshin_textPackage.EPACKAGE_IMPORT:
				sequence_EPackageImport(context, (EPackageImport) semanticObject); 
				return; 
			case Henshin_textPackage.EDGE:
				sequence_Edge(context, (Edge) semanticObject); 
				return; 
			case Henshin_textPackage.EDGES:
				sequence_Edges(context, (Edges) semanticObject); 
				return; 
			case Henshin_textPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case Henshin_textPackage.FORMULA:
				sequence_Formula(context, (Formula) semanticObject); 
				return; 
			case Henshin_textPackage.GRAPH:
				sequence_Graph(context, (Graph) semanticObject); 
				return; 
			case Henshin_textPackage.INDEPENDENT_UNIT:
				sequence_IndependentUnit(context, (IndependentUnit) semanticObject); 
				return; 
			case Henshin_textPackage.INJECTIVE_MATCHING:
				sequence_InjectiveMatching(context, (InjectiveMatching) semanticObject); 
				return; 
			case Henshin_textPackage.INTEGER_VALUE:
				sequence_AtomicExpression(context, (IntegerValue) semanticObject); 
				return; 
			case Henshin_textPackage.ITERATED_UNIT:
				sequence_IteratedUnit(context, (IteratedUnit) semanticObject); 
				return; 
			case Henshin_textPackage.JAVA_ATTRIBUTE_VALUE:
				sequence_AtomicExpression(context, (JavaAttributeValue) semanticObject); 
				return; 
			case Henshin_textPackage.JAVA_CLASS_VALUE:
				sequence_AtomicExpression(context, (JavaClassValue) semanticObject); 
				return; 
			case Henshin_textPackage.JAVA_IMPORT:
				sequence_JavaImport(context, (JavaImport) semanticObject); 
				return; 
			case Henshin_textPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case Henshin_textPackage.LOOP_UNIT:
				sequence_LoopUnit(context, (LoopUnit) semanticObject); 
				return; 
			case Henshin_textPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case Henshin_textPackage.MINUS_EXPRESSION:
				sequence_PlusOrMinusExpression(context, (MinusExpression) semanticObject); 
				return; 
			case Henshin_textPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case Henshin_textPackage.MUL_OR_DIV_EXPRESSION:
				sequence_MulOrDivExpression(context, (MulOrDivExpression) semanticObject); 
				return; 
			case Henshin_textPackage.MULTI_RULE:
				sequence_MultiRule(context, (MultiRule) semanticObject); 
				return; 
			case Henshin_textPackage.MULTI_RULE_REUSE_NODE:
				sequence_MultiRuleReuseNode(context, (MultiRuleReuseNode) semanticObject); 
				return; 
			case Henshin_textPackage.NATURAL_VALUE:
				sequence_AtomicExpression(context, (NaturalValue) semanticObject); 
				return; 
			case Henshin_textPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case Henshin_textPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case Henshin_textPackage.NOT_EXPRESSION:
				sequence_PrimaryExpression(context, (NotExpression) semanticObject); 
				return; 
			case Henshin_textPackage.NUMBER_VALUE:
				sequence_AtomicExpression(context, (NumberValue) semanticObject); 
				return; 
			case Henshin_textPackage.OROR_XOR:
				sequence_ORorXOR(context, (ORorXOR) semanticObject); 
				return; 
			case Henshin_textPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case Henshin_textPackage.PARAMETER:
				sequence_Parameter(context, (org.eclipse.emf.henshin.text.henshin_text.Parameter) semanticObject); 
				return; 
			case Henshin_textPackage.PARAMETER_TYPE:
				sequence_ParameterType(context, (ParameterType) semanticObject); 
				return; 
			case Henshin_textPackage.PARAMETER_VALUE:
				sequence_AtomicExpression(context, (ParameterValue) semanticObject); 
				return; 
			case Henshin_textPackage.PLUS_EXPRESSION:
				sequence_PlusOrMinusExpression(context, (PlusExpression) semanticObject); 
				return; 
			case Henshin_textPackage.PRIORITY_UNIT:
				sequence_PriorityUnit(context, (PriorityUnit) semanticObject); 
				return; 
			case Henshin_textPackage.ROLLBACK:
				sequence_Rollback(context, (Rollback) semanticObject); 
				return; 
			case Henshin_textPackage.RULE:
				sequence_ModelElement(context, (Rule) semanticObject); 
				return; 
			case Henshin_textPackage.STRICT:
				sequence_Strict(context, (Strict) semanticObject); 
				return; 
			case Henshin_textPackage.STRING_VALUE:
				sequence_AtomicExpression(context, (StringValue) semanticObject); 
				return; 
			case Henshin_textPackage.UNIT:
				sequence_ModelElement(context, (Unit) semanticObject); 
				return; 
			case Henshin_textPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Logic returns AND
	 *     ORorXOR returns AND
	 *     ORorXOR.ORorXOR_1_0 returns AND
	 *     AND returns AND
	 *     AND.AND_1_0 returns AND
	 *     Primary returns AND
	 *
	 * Constraint:
	 *     (left=AND_AND_1_0 right=Primary)
	 */
	protected void sequence_AND(ISerializationContext context, AND semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getANDAccess().getANDLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getANDAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=EqualityExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolValue
	 *     OrExpression returns BoolValue
	 *     OrExpression.OrExpression_1_0 returns BoolValue
	 *     AndExpression returns BoolValue
	 *     AndExpression.AndExpression_1_0 returns BoolValue
	 *     EqualityExpression returns BoolValue
	 *     EqualityExpression.EqualityExpression_1_0 returns BoolValue
	 *     ComparisonExpression returns BoolValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BoolValue
	 *     PlusOrMinusExpression returns BoolValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns BoolValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns BoolValue
	 *     MulOrDivExpression returns BoolValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns BoolValue
	 *     PrimaryExpression returns BoolValue
	 *     AtomicExpression returns BoolValue
	 *
	 * Constraint:
	 *     value=EBoolean
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, BoolValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.BOOL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.BOOL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueEBooleanParserRuleCall_7_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerValue
	 *     OrExpression returns IntegerValue
	 *     OrExpression.OrExpression_1_0 returns IntegerValue
	 *     AndExpression returns IntegerValue
	 *     AndExpression.AndExpression_1_0 returns IntegerValue
	 *     EqualityExpression returns IntegerValue
	 *     EqualityExpression.EqualityExpression_1_0 returns IntegerValue
	 *     ComparisonExpression returns IntegerValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns IntegerValue
	 *     PlusOrMinusExpression returns IntegerValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns IntegerValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns IntegerValue
	 *     MulOrDivExpression returns IntegerValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns IntegerValue
	 *     PrimaryExpression returns IntegerValue
	 *     AtomicExpression returns IntegerValue
	 *
	 * Constraint:
	 *     value=NEGATIVE
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, IntegerValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.INTEGER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.INTEGER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueNEGATIVETerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns JavaAttributeValue
	 *     OrExpression returns JavaAttributeValue
	 *     OrExpression.OrExpression_1_0 returns JavaAttributeValue
	 *     AndExpression returns JavaAttributeValue
	 *     AndExpression.AndExpression_1_0 returns JavaAttributeValue
	 *     EqualityExpression returns JavaAttributeValue
	 *     EqualityExpression.EqualityExpression_1_0 returns JavaAttributeValue
	 *     ComparisonExpression returns JavaAttributeValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns JavaAttributeValue
	 *     PlusOrMinusExpression returns JavaAttributeValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns JavaAttributeValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns JavaAttributeValue
	 *     MulOrDivExpression returns JavaAttributeValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns JavaAttributeValue
	 *     PrimaryExpression returns JavaAttributeValue
	 *     AtomicExpression returns JavaAttributeValue
	 *
	 * Constraint:
	 *     value=JavaAttribute
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, JavaAttributeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.JAVA_ATTRIBUTE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.JAVA_ATTRIBUTE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueJavaAttributeParserRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns JavaClassValue
	 *     OrExpression returns JavaClassValue
	 *     OrExpression.OrExpression_1_0 returns JavaClassValue
	 *     AndExpression returns JavaClassValue
	 *     AndExpression.AndExpression_1_0 returns JavaClassValue
	 *     EqualityExpression returns JavaClassValue
	 *     EqualityExpression.EqualityExpression_1_0 returns JavaClassValue
	 *     ComparisonExpression returns JavaClassValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns JavaClassValue
	 *     PlusOrMinusExpression returns JavaClassValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns JavaClassValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns JavaClassValue
	 *     MulOrDivExpression returns JavaClassValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns JavaClassValue
	 *     PrimaryExpression returns JavaClassValue
	 *     AtomicExpression returns JavaClassValue
	 *
	 * Constraint:
	 *     (value=EString (javaParameter+=Expression javaParameter+=Expression*)?)
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, JavaClassValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NaturalValue
	 *     OrExpression returns NaturalValue
	 *     OrExpression.OrExpression_1_0 returns NaturalValue
	 *     AndExpression returns NaturalValue
	 *     AndExpression.AndExpression_1_0 returns NaturalValue
	 *     EqualityExpression returns NaturalValue
	 *     EqualityExpression.EqualityExpression_1_0 returns NaturalValue
	 *     ComparisonExpression returns NaturalValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NaturalValue
	 *     PlusOrMinusExpression returns NaturalValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns NaturalValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns NaturalValue
	 *     MulOrDivExpression returns NaturalValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns NaturalValue
	 *     PrimaryExpression returns NaturalValue
	 *     AtomicExpression returns NaturalValue
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, NaturalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.NATURAL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.NATURAL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueINTTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberValue
	 *     OrExpression returns NumberValue
	 *     OrExpression.OrExpression_1_0 returns NumberValue
	 *     AndExpression returns NumberValue
	 *     AndExpression.AndExpression_1_0 returns NumberValue
	 *     EqualityExpression returns NumberValue
	 *     EqualityExpression.EqualityExpression_1_0 returns NumberValue
	 *     ComparisonExpression returns NumberValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NumberValue
	 *     PlusOrMinusExpression returns NumberValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns NumberValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns NumberValue
	 *     MulOrDivExpression returns NumberValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns NumberValue
	 *     PrimaryExpression returns NumberValue
	 *     AtomicExpression returns NumberValue
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, NumberValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.NUMBER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.NUMBER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueDECIMALTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParameterValue
	 *     OrExpression returns ParameterValue
	 *     OrExpression.OrExpression_1_0 returns ParameterValue
	 *     AndExpression returns ParameterValue
	 *     AndExpression.AndExpression_1_0 returns ParameterValue
	 *     EqualityExpression returns ParameterValue
	 *     EqualityExpression.EqualityExpression_1_0 returns ParameterValue
	 *     ComparisonExpression returns ParameterValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ParameterValue
	 *     PlusOrMinusExpression returns ParameterValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns ParameterValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns ParameterValue
	 *     MulOrDivExpression returns ParameterValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns ParameterValue
	 *     PrimaryExpression returns ParameterValue
	 *     AtomicExpression returns ParameterValue
	 *
	 * Constraint:
	 *     value=[Parameter|ID]
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, ParameterValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.PARAMETER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.PARAMETER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueParameterIDTerminalRuleCall_0_1_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.PARAMETER_VALUE__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringValue
	 *     OrExpression returns StringValue
	 *     OrExpression.OrExpression_1_0 returns StringValue
	 *     AndExpression returns StringValue
	 *     AndExpression.AndExpression_1_0 returns StringValue
	 *     EqualityExpression returns StringValue
	 *     EqualityExpression.EqualityExpression_1_0 returns StringValue
	 *     ComparisonExpression returns StringValue
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringValue
	 *     PlusOrMinusExpression returns StringValue
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns StringValue
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns StringValue
	 *     MulOrDivExpression returns StringValue
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns StringValue
	 *     PrimaryExpression returns StringValue
	 *     AtomicExpression returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Logic returns ConditionGraphRef
	 *     ORorXOR returns ConditionGraphRef
	 *     ORorXOR.ORorXOR_1_0 returns ConditionGraphRef
	 *     AND returns ConditionGraphRef
	 *     AND.AND_1_0 returns ConditionGraphRef
	 *     Primary returns ConditionGraphRef
	 *     Atomic returns ConditionGraphRef
	 *
	 * Constraint:
	 *     conditionGraphRef=[ConditionGraph|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, ConditionGraphRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.CONDITION_GRAPH_REF__CONDITION_GRAPH_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.CONDITION_GRAPH_REF__CONDITION_GRAPH_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getConditionGraphRefConditionGraphIDTerminalRuleCall_1_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.CONDITION_GRAPH_REF__CONDITION_GRAPH_REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     ((actiontype=ActionType? name=[EAttribute|EString] value=Expression) | (update='set' name=[EAttribute|EString] value=Expression))
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns CheckDangling
	 *     CheckDangling returns CheckDangling
	 *
	 * Constraint:
	 *     checkDangling=EBoolean
	 */
	protected void sequence_CheckDangling(ISerializationContext context, CheckDangling semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.CHECK_DANGLING__CHECK_DANGLING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.CHECK_DANGLING__CHECK_DANGLING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckDanglingAccess().getCheckDanglingEBooleanParserRuleCall_1_0(), semanticObject.isCheckDangling());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     OrExpression returns ComparisonExpression
	 *     OrExpression.OrExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     EqualityExpression returns ComparisonExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_ComparisonExpression_1_0 (op='&gt;=' | op='&lt;=' | op='&gt;' | op='&lt;') right=PlusOrMinusExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionEdge returns ConditionEdge
	 *
	 * Constraint:
	 *     (source=[ConditionNodeTypes|ID] target=[ConditionNodeTypes|ID] type=[EReference|EString])
	 */
	protected void sequence_ConditionEdge(ISerializationContext context, ConditionEdge semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.CONDITION_EDGE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.CONDITION_EDGE__SOURCE));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.CONDITION_EDGE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.CONDITION_EDGE__TARGET));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.CONDITION_EDGE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.CONDITION_EDGE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionEdgeAccess().getSourceConditionNodeTypesIDTerminalRuleCall_1_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.CONDITION_EDGE__SOURCE, false));
		feeder.accept(grammarAccess.getConditionEdgeAccess().getTargetConditionNodeTypesIDTerminalRuleCall_3_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.CONDITION_EDGE__TARGET, false));
		feeder.accept(grammarAccess.getConditionEdgeAccess().getTypeEReferenceEStringParserRuleCall_5_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.CONDITION_EDGE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionGraphElements returns ConditionEdges
	 *     ConditionEdges returns ConditionEdges
	 *
	 * Constraint:
	 *     (edges+=ConditionEdge edges+=ConditionEdge*)
	 */
	protected void sequence_ConditionEdges(ISerializationContext context, ConditionEdges semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionGraph returns ConditionGraph
	 *
	 * Constraint:
	 *     (name=ID conditionGraphElements+=ConditionGraphElements*)
	 */
	protected void sequence_ConditionGraph(ISerializationContext context, ConditionGraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionGraphElements returns ConditionNode
	 *     ConditionNodeTypes returns ConditionNode
	 *     ConditionNode returns ConditionNode
	 *
	 * Constraint:
	 *     (name=ID type=[EClass|EString] attribute+=Match*)
	 */
	protected void sequence_ConditionNode(ISerializationContext context, ConditionNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionGraphElements returns ConditionReuseNode
	 *     ConditionReuseNode returns ConditionReuseNode
	 *
	 * Constraint:
	 *     (name=[ConditionNodeTypes|ID] attribute+=Match*)
	 */
	protected void sequence_ConditionReuseNode(ISerializationContext context, ConditionReuseNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns ConditionalUnit
	 *     ConditionalUnit returns ConditionalUnit
	 *
	 * Constraint:
	 *     (if+=UnitElement+ then+=UnitElement+ else+=UnitElement*)
	 */
	protected void sequence_ConditionalUnit(ISerializationContext context, ConditionalUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns Conditions
	 *     Conditions returns Conditions
	 *
	 * Constraint:
	 *     (attributeConditions+=Expression attributeConditions+=Expression*)
	 */
	protected void sequence_Conditions(ISerializationContext context, Conditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EPackageImport returns EPackageImport
	 *
	 * Constraint:
	 *     ref=[EPackage|EString]
	 */
	protected void sequence_EPackageImport(ISerializationContext context, EPackageImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.EPACKAGE_IMPORT__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.EPACKAGE_IMPORT__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEPackageImportAccess().getRefEPackageEStringParserRuleCall_1_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.EPACKAGE_IMPORT__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns Edge
	 *
	 * Constraint:
	 *     (actiontype=ActionType? source=[RuleNodeTypes|ID] target=[RuleNodeTypes|ID] type=[EReference|EString])
	 */
	protected void sequence_Edge(ISerializationContext context, Edge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphElements returns Edges
	 *     Edges returns Edges
	 *
	 * Constraint:
	 *     (edges+=Edge edges+=Edge*)
	 */
	protected void sequence_Edges(ISerializationContext context, Edges semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EqualityExpression
	 *     OrExpression returns EqualityExpression
	 *     OrExpression.OrExpression_1_0 returns EqualityExpression
	 *     AndExpression returns EqualityExpression
	 *     AndExpression.AndExpression_1_0 returns EqualityExpression
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *
	 * Constraint:
	 *     (left=EqualityExpression_EqualityExpression_1_0 (op='==' | op='!=') right=ComparisonExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphElements returns Formula
	 *     Formula returns Formula
	 *     ConditionGraphElements returns Formula
	 *
	 * Constraint:
	 *     (formula=Logic conditionGraphs+=ConditionGraph+)
	 */
	protected void sequence_Formula(ISerializationContext context, Formula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns Graph
	 *     Graph returns Graph
	 *
	 * Constraint:
	 *     graphElements+=GraphElements*
	 */
	protected void sequence_Graph(ISerializationContext context, Graph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns IndependentUnit
	 *     IndependentUnit returns IndependentUnit
	 *
	 * Constraint:
	 *     (listOfLists+=List listOfLists+=List*)
	 */
	protected void sequence_IndependentUnit(ISerializationContext context, IndependentUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns InjectiveMatching
	 *     InjectiveMatching returns InjectiveMatching
	 *
	 * Constraint:
	 *     injectiveMatching=EBoolean
	 */
	protected void sequence_InjectiveMatching(ISerializationContext context, InjectiveMatching semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.INJECTIVE_MATCHING__INJECTIVE_MATCHING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.INJECTIVE_MATCHING__INJECTIVE_MATCHING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInjectiveMatchingAccess().getInjectiveMatchingEBooleanParserRuleCall_1_0(), semanticObject.isInjectiveMatching());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns IteratedUnit
	 *     IteratedUnit returns IteratedUnit
	 *
	 * Constraint:
	 *     (iterations=Expression subElement+=UnitElement+)
	 */
	protected void sequence_IteratedUnit(ISerializationContext context, IteratedUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleElement returns JavaImport
	 *     JavaImport returns JavaImport
	 *
	 * Constraint:
	 *     packagename=EString
	 */
	protected void sequence_JavaImport(ISerializationContext context, JavaImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.JAVA_IMPORT__PACKAGENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.JAVA_IMPORT__PACKAGENAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJavaImportAccess().getPackagenameEStringParserRuleCall_1_0(), semanticObject.getPackagename());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     subElements+=UnitElement+
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns LoopUnit
	 *     LoopUnit returns LoopUnit
	 *
	 * Constraint:
	 *     subElement+=UnitElement+
	 */
	protected void sequence_LoopUnit(ISerializationContext context, LoopUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (name=[EAttribute|EString] value=Expression)
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.MATCH__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.MATCH__NAME));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.MATCH__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.MATCH__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatchAccess().getNameEAttributeEStringParserRuleCall_0_0_1(), semanticObject.eGet(Henshin_textPackage.Literals.MATCH__NAME, false));
		feeder.accept(grammarAccess.getMatchAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Rule
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? ruleElements+=RuleElement+)
	 */
	protected void sequence_ModelElement(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Unit
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? unitElements+=UnitElement+)
	 */
	protected void sequence_ModelElement(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (ePackageimports+=EPackageImport+ transformationsystem+=ModelElement*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDivExpression
	 *     OrExpression returns MulOrDivExpression
	 *     OrExpression.OrExpression_1_0 returns MulOrDivExpression
	 *     AndExpression returns MulOrDivExpression
	 *     AndExpression.AndExpression_1_0 returns MulOrDivExpression
	 *     EqualityExpression returns MulOrDivExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MulOrDivExpression
	 *     ComparisonExpression returns MulOrDivExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MulOrDivExpression
	 *     PlusOrMinusExpression returns MulOrDivExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns MulOrDivExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns MulOrDivExpression
	 *     MulOrDivExpression returns MulOrDivExpression
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns MulOrDivExpression
	 *
	 * Constraint:
	 *     (left=MulOrDivExpression_MulOrDivExpression_1_0 (op='*' | op='/') right=PrimaryExpression)
	 */
	protected void sequence_MulOrDivExpression(ISerializationContext context, MulOrDivExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphElements returns MultiRuleReuseNode
	 *     RuleNodeTypes returns MultiRuleReuseNode
	 *     MultiRuleReuseNode returns MultiRuleReuseNode
	 *
	 * Constraint:
	 *     (name=[Node|ID] attribute+=Attribute*)
	 */
	protected void sequence_MultiRuleReuseNode(ISerializationContext context, MultiRuleReuseNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphElements returns MultiRule
	 *     MultiRule returns MultiRule
	 *
	 * Constraint:
	 *     (name=ID multiruleElements+=RuleElement+)
	 */
	protected void sequence_MultiRule(ISerializationContext context, MultiRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GraphElements returns Node
	 *     RuleNodeTypes returns Node
	 *     Node returns Node
	 *     ConditionNodeTypes returns Node
	 *
	 * Constraint:
	 *     (actiontype=ActionType? name=ID nodetype=[EClass|EString] attribute+=Attribute*)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Logic returns ORorXOR
	 *     ORorXOR returns ORorXOR
	 *     ORorXOR.ORorXOR_1_0 returns ORorXOR
	 *     AND returns ORorXOR
	 *     AND.AND_1_0 returns ORorXOR
	 *     Primary returns ORorXOR
	 *
	 * Constraint:
	 *     (left=ORorXOR_ORorXOR_1_0 (op='OR' | op='XOR') right=AND)
	 */
	protected void sequence_ORorXOR(ISerializationContext context, ORorXOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterType returns ParameterType
	 *
	 * Constraint:
	 *     (enumType=Type | type=[EClass|EString])
	 */
	protected void sequence_ParameterType(ISerializationContext context, ParameterType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (kind=ParameterKindRule? name=ID type=ParameterType)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.eclipse.emf.henshin.text.henshin_text.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinusExpression
	 *     OrExpression returns MinusExpression
	 *     OrExpression.OrExpression_1_0 returns MinusExpression
	 *     AndExpression returns MinusExpression
	 *     AndExpression.AndExpression_1_0 returns MinusExpression
	 *     EqualityExpression returns MinusExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MinusExpression
	 *     ComparisonExpression returns MinusExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MinusExpression
	 *     PlusOrMinusExpression returns MinusExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns MinusExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns MinusExpression
	 *
	 * Constraint:
	 *     (left=PlusOrMinusExpression_MinusExpression_1_0_1_0 right=MulOrDivExpression)
	 */
	protected void sequence_PlusOrMinusExpression(ISerializationContext context, MinusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.MINUS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.MINUS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.MINUS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.MINUS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getMinusExpressionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getRightMulOrDivExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PlusExpression
	 *     OrExpression returns PlusExpression
	 *     OrExpression.OrExpression_1_0 returns PlusExpression
	 *     AndExpression returns PlusExpression
	 *     AndExpression.AndExpression_1_0 returns PlusExpression
	 *     EqualityExpression returns PlusExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns PlusExpression
	 *     ComparisonExpression returns PlusExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns PlusExpression
	 *     PlusOrMinusExpression returns PlusExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns PlusExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns PlusExpression
	 *
	 * Constraint:
	 *     (left=PlusOrMinusExpression_PlusExpression_1_0_0_0 right=MulOrDivExpression)
	 */
	protected void sequence_PlusOrMinusExpression(ISerializationContext context, PlusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.PLUS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.PLUS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.PLUS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.PLUS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getPlusExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusExpressionAccess().getRightMulOrDivExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BracketExpression
	 *     OrExpression returns BracketExpression
	 *     OrExpression.OrExpression_1_0 returns BracketExpression
	 *     AndExpression returns BracketExpression
	 *     AndExpression.AndExpression_1_0 returns BracketExpression
	 *     EqualityExpression returns BracketExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns BracketExpression
	 *     ComparisonExpression returns BracketExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BracketExpression
	 *     PlusOrMinusExpression returns BracketExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns BracketExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns BracketExpression
	 *     MulOrDivExpression returns BracketExpression
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns BracketExpression
	 *     PrimaryExpression returns BracketExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, BracketExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.BRACKET_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.BRACKET_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0 returns NotExpression
	 *     EqualityExpression returns NotExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns NotExpression
	 *     ComparisonExpression returns NotExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NotExpression
	 *     PlusOrMinusExpression returns NotExpression
	 *     PlusOrMinusExpression.PlusExpression_1_0_0_0 returns NotExpression
	 *     PlusOrMinusExpression.MinusExpression_1_0_1_0 returns NotExpression
	 *     MulOrDivExpression returns NotExpression
	 *     MulOrDivExpression.MulOrDivExpression_1_0 returns NotExpression
	 *     PrimaryExpression returns NotExpression
	 *
	 * Constraint:
	 *     expression=PrimaryExpression
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getExpressionPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Logic returns Not
	 *     ORorXOR returns Not
	 *     ORorXOR.ORorXOR_1_0 returns Not
	 *     AND returns Not
	 *     AND.AND_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     negation=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.NOT__NEGATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.NOT__NEGATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getNegationPrimaryParserRuleCall_1_2_0(), semanticObject.getNegation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns PriorityUnit
	 *     PriorityUnit returns PriorityUnit
	 *
	 * Constraint:
	 *     (listOfLists+=List listOfLists+=List*)
	 */
	protected void sequence_PriorityUnit(ISerializationContext context, PriorityUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns Rollback
	 *     SequentialProperties returns Rollback
	 *     Rollback returns Rollback
	 *
	 * Constraint:
	 *     rollback=EBoolean
	 */
	protected void sequence_Rollback(ISerializationContext context, Rollback semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.ROLLBACK__ROLLBACK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRollbackAccess().getRollbackEBooleanParserRuleCall_1_0(), semanticObject.isRollback());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns Strict
	 *     SequentialProperties returns Strict
	 *     Strict returns Strict
	 *
	 * Constraint:
	 *     strict=EBoolean
	 */
	protected void sequence_Strict(ISerializationContext context, Strict semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Henshin_textPackage.Literals.STRICT__STRICT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Henshin_textPackage.Literals.STRICT__STRICT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStrictAccess().getStrictEBooleanParserRuleCall_1_0(), semanticObject.isStrict());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns Call
	 *
	 * Constraint:
	 *     (elementCall=[ModelElement|ID] (parameters+=[Parameter|ID] parameters+=[Parameter|ID]*)?)
	 */
	protected void sequence_UnitElement(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     subSequence+=UnitElement+
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
